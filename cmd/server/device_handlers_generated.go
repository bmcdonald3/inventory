// Code generated by Fabrica dev. DO NOT EDIT.
// Copyright Â© 2025 OpenCHAMI a Series of LF Projects, LLC
//
// SPDX-License-Identifier: MIT
//
// This file contains REST API handlers for Device resources.
// Generated from: pkg/codegen/templates/handlers.go.tmpl
//
package main

import (
    "encoding/json"
    "fmt"
    "io"
    "net/http"

    "github.com/go-chi/chi/v5"
	// <<< FIX: Import the internal/middleware package
	middleware "github.com/user/inventory-api/internal/middleware"
    "github.com/openchami/fabrica/pkg/patch"
    "github.com/openchami/fabrica/pkg/resource"
    "github.com/openchami/fabrica/pkg/validation"
    "github.com/openchami/fabrica/pkg/versioning"
    "github.com/user/inventory-api/internal/storage"
    "github.com/user/inventory-api/pkg/resources/device"
)

// GetDevices returns all Device resources
func GetDevices(w http.ResponseWriter, r *http.Request) {
    devices, err := storage.LoadAllDevices(r.Context())
    if err != nil {
        respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to load devices: %w", err))
        return
    }
    respondJSON(w, http.StatusOK, devices)
}

// GetDevice returns a specific Device resource by UID
func GetDevice(w http.ResponseWriter, r *http.Request) {
    uid := chi.URLParam(r, "uid")
    if uid == "" {
        respondError(w, http.StatusBadRequest, fmt.Errorf("Device UID is required"))
        return
    }
    device, err := storage.LoadDevice(r.Context(), uid)
    if err != nil {
        respondError(w, http.StatusNotFound, fmt.Errorf("Device not found: %w", err))
        return
    }
    respondJSON(w, http.StatusOK, device)
}

// CreateDevice creates a new Device resource
func CreateDevice(w http.ResponseWriter, r *http.Request) {
    var req CreateDeviceRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        respondError(w, http.StatusBadRequest, fmt.Errorf("invalid request body: %w", err))
        return
    }
    versionCtx := versioning.GetVersionContext(r.Context())
    uid, err := resource.GenerateUIDForResource("Device")
    if err != nil {
        respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to generate UID: %w", err))
        return
    }
    device := &device.Device{
        Resource: resource.Resource{
            APIVersion:    versionCtx.GroupVersion,
            Kind:          "Device",
            SchemaVersion: versionCtx.ServeVersion,
        },
        Spec: req.DeviceSpec,
    }
    device.Metadata.Initialize(req.Name, uid)
    for k, v := range req.Labels {
        device.SetLabel(k, v)
    }
    for k, v := range req.Annotations {
        device.SetAnnotation(k, v)
    }
    if err := validation.ValidateResource(device); err != nil {
        respondError(w, http.StatusBadRequest, fmt.Errorf("validation failed: %w", err))
        return
    }
    if err := validation.ValidateWithContext(r.Context(), device); err != nil {
        respondError(w, http.StatusBadRequest, fmt.Errorf("validation failed: %w", err))
        return
    }
    if err := storage.SaveDevice(r.Context(), device); err != nil {
        respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save Device: %w", err))
        return
    }
    // <<< FIX: Call the function with the 'middleware.' prefix
    if err := middleware.PublishResourceEvent(r.Context(), "created", "Device", device.GetUID(), device); err != nil {
        fmt.Printf("Warning: Failed to publish resource created event for Device %s: %v\n", device.GetUID(), err)
    }
    respondJSON(w, http.StatusCreated, device)
}

// UpdateDevice updates the spec of an existing Device resource
func UpdateDevice(w http.ResponseWriter, r *http.Request) {
    uid := chi.URLParam(r, "uid")
    if uid == "" {
        respondError(w, http.StatusBadRequest, fmt.Errorf("Device UID is required"))
        return
    }
    device, err := storage.LoadDevice(r.Context(), uid)
    if err != nil {
        respondError(w, http.StatusNotFound, fmt.Errorf("Device not found: %w", err))
        return
    }
    var req UpdateDeviceRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        respondError(w, http.StatusBadRequest, fmt.Errorf("invalid request body: %w", err))
        return
    }
    if req.Name != "" {
        device.SetName(req.Name)
    }
    device.Spec = req.DeviceSpec
    for k, v := range req.Labels {
        device.SetLabel(k, v)
    }
    for k, v := range req.Annotations {
        device.SetAnnotation(k, v)
    }
    device.Touch()
    if err := storage.SaveDevice(r.Context(), device); err != nil {
        respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save Device: %w", err))
        return
    }
    // <<< FIX: Call the function with the 'middleware.' prefix
    if err := middleware.PublishResourceEvent(r.Context(), "updated", "Device", device.GetUID(), device); err != nil {
        fmt.Printf("Warning: Failed to publish resource updated event for Device %s: %v\n", device.GetUID(), err)
    }
    respondJSON(w, http.StatusOK, device)
}

// PatchDevice patches an existing Device resource spec
func PatchDevice(w http.ResponseWriter, r *http.Request) {
    uid := chi.URLParam(r, "uid")
    if uid == "" {
        respondError(w, http.StatusBadRequest, fmt.Errorf("Device UID is required"))
        return
    }
    device, err := storage.LoadDevice(r.Context(), uid)
    if err != nil {
        respondError(w, http.StatusNotFound, fmt.Errorf("Device not found: %w", err))
        return
    }
    patchData, err := io.ReadAll(r.Body)
    if err != nil {
        respondError(w, http.StatusBadRequest, fmt.Errorf("failed to read patch data: %w", err))
        return
    }
    currentSpecJSON, err := json.Marshal(device.Spec)
    if err != nil {
        respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to marshal current spec: %w", err))
        return
    }
    contentType := r.Header.Get("Content-Type")
    patchType := patch.DetectPatchType(contentType)
    patchResult, err := patch.ApplyPatchWithOptions(currentSpecJSON, patchData, patchType, patch.PatchOptions{
        AllowAddFields:    true,
        AllowRemoveFields: true,
    })
    if err != nil {
        respondError(w, http.StatusUnprocessableEntity, fmt.Errorf("failed to apply patch to spec: %w", err))
        return
    }
    if err := json.Unmarshal(patchResult.Updated, &device.Spec); err != nil {
        respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to unmarshal patched spec: %w", err))
        return
    }
    device.Touch()
    if err := storage.SaveDevice(r.Context(), device); err != nil {
        respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save patched Device: %w", err))
        return
    }
    // <<< FIX: Call the function with the 'middleware.' prefix
    if err := middleware.PublishResourceEvent(r.Context(), "patched", "Device", device.GetUID(), device); err != nil {
        fmt.Printf("Warning: Failed to publish resource patched event for Device %s: %v\n", device.GetUID(), err)
    }
    respondJSON(w, http.StatusOK, device)
}

// UpdateDeviceStatus updates only the status of a Device resource
func UpdateDeviceStatus(w http.ResponseWriter, r *http.Request) {
    uid := chi.URLParam(r, "uid")
    if uid == "" {
        respondError(w, http.StatusBadRequest, fmt.Errorf("Device UID is required"))
        return
    }
    res, err := storage.LoadDevice(r.Context(), uid)
    if err != nil {
        respondError(w, http.StatusNotFound, fmt.Errorf("Device not found: %w", err))
        return
    }
    var statusUpdate device.DeviceStatus
    if err := json.NewDecoder(r.Body).Decode(&statusUpdate); err != nil {
        respondError(w, http.StatusBadRequest, fmt.Errorf("invalid status body: %w", err))
        return
    }
    res.Status = statusUpdate
    res.Touch()
    if err := storage.SaveDevice(r.Context(), res); err != nil {
        respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save Device status: %w", err))
        return
    }
    // <<< FIX: Call the function with the 'middleware.' prefix
    if err := middleware.PublishResourceEvent(r.Context(), "updated", "Device", res.GetUID(), res); err != nil {
        fmt.Printf("Warning: Failed to publish status update event for Device %s: %v\n", res.GetUID(), err)
    }
    respondJSON(w, http.StatusOK, res)
}

// PatchDeviceStatus patches only the status of a Device resource
func PatchDeviceStatus(w http.ResponseWriter, r *http.Request) {
    uid := chi.URLParam(r, "uid")
    if uid == "" {
        respondError(w, http.StatusBadRequest, fmt.Errorf("Device UID is required"))
        return
    }
    res, err := storage.LoadDevice(r.Context(), uid)
    if err != nil {
        respondError(w, http.StatusNotFound, fmt.Errorf("Device not found: %w", err))
        return
    }
    patchData, err := io.ReadAll(r.Body)
    if err != nil {
        respondError(w, http.StatusBadRequest, fmt.Errorf("failed to read patch data: %w", err))
        return
    }
    currentStatusJSON, err := json.Marshal(res.Status)
    if err != nil {
        respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to marshal current status: %w", err))
        return
    }
    contentType := r.Header.Get("Content-Type")
    patchType := patch.DetectPatchType(contentType)
    patchResult, err := patch.ApplyPatchWithOptions(currentStatusJSON, patchData, patchType, patch.PatchOptions{
        AllowAddFields:    true,
        AllowRemoveFields: false,
    })
    if err != nil {
        respondError(w, http.StatusUnprocessableEntity, fmt.Errorf("failed to apply patch to status: %w", err))
        return
    }
    if err := json.Unmarshal(patchResult.Updated, &res.Status); err != nil {
        respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to unmarshal patched status: %w", err))
        return
    }
    res.Touch()
    if err := storage.SaveDevice(r.Context(), res); err != nil {
        respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to save patched Device status: %w", err))
        return
    }
    // <<< FIX: Call the function with the 'middleware.' prefix
    if err := middleware.PublishResourceEvent(r.Context(), "patched", "Device", res.GetUID(), res); err != nil {
        fmt.Printf("Warning: Failed to publish status patch event for Device %s: %v\n", res.GetUID(), err)
    }
    respondJSON(w, http.StatusOK, res)
}

// DeleteDevice deletes a Device resource
func DeleteDevice(w http.ResponseWriter, r *http.Request) {
    uid := chi.URLParam(r, "uid")
    if uid == "" {
        respondError(w, http.StatusBadRequest, fmt.Errorf("Device UID is required"))
        return
    }
    device, err := storage.LoadDevice(r.Context(), uid)
    if err != nil {
        respondError(w, http.StatusNotFound, fmt.Errorf("Device not found: %w", err))
        return
    }
    if err := storage.DeleteDevice(r.Context(), uid); err != nil {
        respondError(w, http.StatusInternalServerError, fmt.Errorf("failed to delete Device: %w", err))
        return
    }
    // <<< FIX: Call the function with the 'middleware.' prefix
    if err := middleware.PublishResourceEvent(r.Context(), "deleted", "Device", device.GetUID(), device); err != nil {
        fmt.Printf("Warning: Failed to publish resource deleted event for Device %s: %v\n", device.GetUID(), err)
    }
    respondJSON(w, http.StatusOK, &DeleteResponse{
        Message: "Device deleted successfully",
        UID:     uid,
    })
}